{"version":3,"sources":["../src/parser.js"],"names":["splitLabelToCommands","strip","containIncludeCommand","parseVariablesFromLabel","generateEmbedCode","getContent","embedCode","parse","path","require","Handlebars","logger","markdownLinkFormatRegExp","codeCounter","count","label","result","split","map","command","trim","filter","length","s","undefined","indents","match","m","smallestIndent","sort","a","b","replace","RegExp","commands","reg","some","test","kvMap","kv","Object","assign","beginEx","endEx","sepEx","kvsepEx","spacesEx","quotesEx","keys","forEach","keyEx","key","valEx","error","regStr","res","freeze","fileName","originalPath","content","tContent","contextMap","handlebars","compile","filePath","code","basename","kvmparsed","kvm","unindent","start","end","marker","baseDir","options","results","exec","all","absolutePath","resolve","replacedContent","push","target","replaced"],"mappings":"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","file":"parser.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nconst path = require(\"path\");\nconst Handlebars = require(\"handlebars\");\nconst logger = require(\"winston-color\");\nimport {defaultKeyValueMap, initOptions, checkMapTypes, convertValue} from \"./options.js\";\nimport {getLang} from \"./language-detection\";\nimport {getMarker, hasMarker, markerSliceCode, removeMarkers} from \"./marker\";\nimport {sliceCode, hasSliceRange, getSliceRange} from \"./slicer\";\nimport {hasTitle} from \"./title\";\nimport {getTemplateContent, readFileFromPath} from \"./template\";\nconst markdownLinkFormatRegExp = /\\[([^\\]]*?)\\]\\(([^\\)]*?)\\)/gm;\n\n/**\n * A counter to count how many code are imported.\n */\nvar codeCounter = (function() {\n    var count = 0;\n    return function() {\n        return count++;\n    };  // Return and increment\n}());\n\n/**\n * split label to commands\n * @param {string} label\n * @returns {Array}\n */\nexport function splitLabelToCommands(label = \"\") {\n    const result = label.split(/(:|[,\\s])/);\n    if (!result) {\n        return [];\n    }\n    // remove null command\n    return result.map(command => {\n        return command.trim();\n    }).filter(command => {\n        return command.length > 0;\n    });\n}\n\n/**\n * Unindent code\n * @param {string} s\n * @return {string}\n */\nexport function strip(s) {\n    // inspired from https://github.com/rails/rails/blob/master/activesupport/lib/active_support/core_ext/string/strip.rb\n    if ((s === undefined) || (s === \"\")) {\n        return s;\n    }\n    const indents = s.split(/\\n/).map(s => s.match(/^[ \\t]*(?=\\S)/)).filter(m => m).map(m => m[0]);\n    const smallestIndent = indents.sort((a, b) => a.length - b.length)[0];\n    return s.replace(new RegExp(`^${smallestIndent}`, \"gm\"), \"\");\n}\n\n/**\n * if contain \"include\" or \"import\" command, then return true\n * @param {Array} commands\n * @returns {boolean}\n */\nexport function containIncludeCommand(commands = []) {\n    const reg = /^(include|import)$/;\n    return commands.some(command => {\n        return reg.test(command.trim());\n    });\n}\n\n/** Parse the command label and return a new key-value object\n * @example\n *      [import,title:\"<thetitle>\",label:\"<thelabel>\"](path/to/file.ext)\n * @param {object} kvMap\n * @param {string} label\n * @return {object}\n */\nexport function parseVariablesFromLabel(kvMap, label) {\n    const kv = Object.assign({}, kvMap);\n    const beginEx = \"\\^.*\";\n    const endEx = \".*\\$\";\n    const sepEx = \",?\";\n    const kvsepEx = \"[:=]\";\n    const spacesEx = \"\\\\s*\";\n    const quotesEx = \"[\\\"']\";\n\n    Object.keys(kv).forEach(key => {\n        let keyEx = \"(\" + key + \")\";\n        let valEx = \"([-\\\\w\\\\s]*)\";\n        if (key === \"marker\") {\n            keyEx = \"(import|include)\";\n            valEx = \"(([-\\\\w\\\\s]*,?)*)\";\n        }\n        // Add value check here\n        switch (typeof defaultKeyValueMap[key]) {\n        case \"string\":\n            valEx = quotesEx + valEx + quotesEx;\n            break;\n        case \"boolean\":\n                // no quotes\n            valEx = quotesEx + \"?(true|false)\" + quotesEx + \"?\";\n            break;\n        default:\n            logger.error(\"include-codeblock: parseVariablesFromLabel: key type `\" + typeof defaultKeyValueMap[key] + \"` unknown (see options.js)\");\n            break;\n        }\n        // Val type cast to string.\n        const regStr = beginEx + sepEx + spacesEx + keyEx +\n            spacesEx + kvsepEx + spacesEx + valEx + spacesEx + sepEx + endEx;\n        const reg = new RegExp(regStr);\n        const res = label.match(reg);\n        if (res) {\n            kv[key] = convertValue(res[2], typeof defaultKeyValueMap[key]);\n        }\n    });\n    return Object.freeze(kv);\n}\n\n/**\n * generate code from options\n * @param {object} kvMap\n * @param {string} fileName\n * @param {string} originalPath\n * @param {string} content\n * @return {string}\n */\nexport function generateEmbedCode(kvMap,\n    {fileName, originalPath, content}) {\n    const tContent = getTemplateContent(kvMap);\n    const kv = Object.assign({}, kvMap);\n    const count = hasTitle(kv) ? codeCounter() : -1;\n    checkMapTypes(kvMap, \"generatedEmbedCode\");\n    const contextMap = Object.assign({}, kvMap, {\n        \"content\": content,\n        \"count\": count,\n        \"fileName\": fileName,\n        \"originalPath\": originalPath\n    });\n    // compile template\n    const handlebars = Handlebars.compile(tContent);\n    // compile with data.\n    return handlebars(contextMap);\n}\n\n/**\n * return content from file or url.\n * @param {string} filePath\n * @param {string} originalPath\n * @return {string}\n */\nexport function getContent(filePath, originalPath) {\n    return readFileFromPath(filePath);\n}\n\n/**\n * generate code with options\n * @param {object} kvMap\n * @param {string} filePath\n * @param {string} originalPath\n * @param {string} label\n * @return {string}\n */\nexport function embedCode(kvMap,\n    {filePath, originalPath, label}) {\n    const code = getContent(filePath, originalPath);\n    const fileName = path.basename(filePath);\n    const kvmparsed = parseVariablesFromLabel(kvMap, label);\n    const kvm = getLang(kvmparsed, originalPath);\n    const unindent = kvm.unindent;\n\n    var content = code;\n    // Slice content via line numbers.\n    if (hasSliceRange(label)) {\n        const [start, end] = getSliceRange(label);\n        content = sliceCode(code, start, end);\n    } else if (hasMarker(kvm)) {\n        // Slice content via markers.\n        const marker = getMarker(kvm);\n        content = removeMarkers(markerSliceCode(code, marker));\n    }\n    if (unindent === true) {\n        content = strip(content);\n    }\n    return generateEmbedCode(\n        kvm,\n        {fileName, originalPath, content}\n    );\n}\n\n/**\n * Parse command using options from pluginConfig.\n * @param {string} content\n * @param {string} baseDir\n * @param {{template?: string}} options\n * @return {Array}\n */\nexport function parse(content, baseDir, options = {}) {\n    const results = [];\n    const kvMap = initOptions(options);\n    let res = true;\n    while ((res = markdownLinkFormatRegExp.exec(content))) {\n        const [all, label, originalPath] = res;\n        const commands = splitLabelToCommands(label);\n        if (containIncludeCommand(commands)) {\n            const absolutePath = path.resolve(baseDir, originalPath);\n            const replacedContent = embedCode(\n                kvMap,\n                {\n                    filePath: absolutePath,\n                    originalPath: originalPath,\n                    label\n                });\n            results.push({\n                target: all,\n                replaced: replacedContent\n            });\n        }\n    }\n    return results;\n}\n"]}